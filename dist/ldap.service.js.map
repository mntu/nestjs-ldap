{"version":3,"file":"ldap.service.js","sourceRoot":"","sources":["../lib/ldap.service.ts"],"names":[],"mappings":"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","sourcesContent":["//#region Imports NPM\r\nimport { Inject, Injectable, LoggerService, Logger } from '@nestjs/common';\r\nimport CacheManager from 'cache-manager';\r\nimport RedisStore from 'cache-manager-ioredis';\r\nimport { parse as urlLibParse } from 'url';\r\nimport bcrypt from 'bcrypt';\r\n//#endregion\r\n//#region Imports Local\r\nimport type {\r\n    LdapModuleOptions,\r\n    LDAPCache,\r\n    LdapResponseUser,\r\n    LdapResponseGroup,\r\n    LdapAddEntry,\r\n    LoggerContext,\r\n} from './ldap.interface';\r\nimport { LDAP_OPTIONS } from './ldap.interface';\r\nimport { Change } from './ldap/change';\r\nimport { LdapDomain } from './ldap.class';\r\nimport * as Ldap from \"ldapjs\";\r\n//#endregion\r\n\r\nconst LDAP_PASSWORD_NULL =\r\n    '2058e76c5f3d68e12d7eec7e334fece75b0552edc5348f85c7889404d9211a36';\r\n\r\n@Injectable()\r\nexport class LdapService {\r\n    public ldapDomains: LdapDomain[];\r\n\r\n    private logger: LoggerService;\r\n    private cache?: CacheManager.Cache;\r\n    private cacheSalt: string;\r\n    private cacheTtl: number;\r\n\r\n    /**\r\n     * Create an LDAP class.\r\n     *\r\n     * @param {LdapModuleOptions} opts Config options\r\n     * @param {LogService} logger Logger service\r\n     * @param {ConfigService} configService Config service\r\n     * @constructor\r\n     */\r\n    constructor(\r\n        @Inject(LDAP_OPTIONS) private readonly options: LdapModuleOptions,\r\n    ) {\r\n        this.logger = options.logger;\r\n\r\n        if (options.cacheUrl || options.cache) {\r\n            this.cacheTtl = options.cacheTtl || 600;\r\n            this.cacheSalt = bcrypt.genSaltSync(6);\r\n\r\n            if (options.cache) {\r\n                this.cache = CacheManager.caching({\r\n                    store: RedisStore,\r\n                    redisInstance: options.cache,\r\n                    keyPrefix: 'LDAP:',\r\n                    ttl: this.cacheTtl,\r\n                });\r\n            } else if (options.cacheUrl) {\r\n                const redisArray = urlLibParse(options.cacheUrl);\r\n                if (\r\n                    redisArray &&\r\n                    (redisArray.protocol === 'redis:' ||\r\n                        redisArray.protocol === 'rediss:')\r\n                ) {\r\n                    let username: string | undefined;\r\n                    let password: string | undefined;\r\n                    const db = parseInt(\r\n                        redisArray.pathname?.slice(1) || '0',\r\n                        10,\r\n                    );\r\n                    if (redisArray.auth) {\r\n                        [username, password] = redisArray.auth.split(':');\r\n                    }\r\n\r\n                    this.cache = CacheManager.caching({\r\n                        store: RedisStore,\r\n                        host: redisArray.hostname,\r\n                        port: parseInt(redisArray.port || '6379', 10),\r\n                        username,\r\n                        password,\r\n                        db,\r\n                        keyPrefix: 'LDAP:',\r\n                        ttl: this.cacheTtl,\r\n                    });\r\n                }\r\n            }\r\n            if (this.cache?.store) {\r\n                this.logger.debug!({\r\n                    message: 'Redis connection: success',\r\n                    context: LdapService.name,\r\n                    function: 'constructor',\r\n                });\r\n            } else {\r\n                this.logger.error({\r\n                    message: 'Redis connection: some error',\r\n                    context: LdapService.name,\r\n                    function: 'constructor',\r\n                });\r\n            }\r\n        } else {\r\n            this.cacheSalt = '';\r\n            this.cacheTtl = 0;\r\n        }\r\n\r\n        this.ldapDomains = this.options.domains.map(\r\n            (opts) => new LdapDomain(opts, this.logger),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Search user by Username\r\n     *\r\n     * @async\r\n     * @param {string} userByUsername user name\r\n     * @returns {Promise<LdapResponseUser>} User in LDAP\r\n     */\r\n    public async searchByUsername({\r\n        username,\r\n        domain,\r\n        cache = true,\r\n        loggerContext,\r\n    }: {\r\n        username: string;\r\n        domain: string;\r\n        cache?: boolean;\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<LdapResponseUser | undefined> {\r\n        const cachedID = `user:${domain}:${username}`;\r\n\r\n        if (cache && this.cache) {\r\n            // Check cache. 'cached' is `{password: <hashed-password>, user: <user>}`.\r\n            const cached = await this.cache.get<LDAPCache>(cachedID);\r\n            if (cached && cached.user && cached.user.sAMAccountName) {\r\n                this.logger.debug!({\r\n                    message: `From cache: ${cached.user.sAMAccountName}`,\r\n                    context: LdapService.name,\r\n                    function: 'searchByUsername',\r\n                    ...loggerContext,\r\n                });\r\n\r\n                return cached.user as LdapResponseUser;\r\n            }\r\n        }\r\n\r\n        const domainLdap = this.ldapDomains.find(\r\n            (value) => value.domainName === domain,\r\n        );\r\n        if (!domainLdap) {\r\n            this.logger.debug!({\r\n                message: `Domain does not exist: ${domain}`,\r\n                context: LdapService.name,\r\n                function: 'searchByUsername',\r\n                ...loggerContext,\r\n            });\r\n            throw new Error(`Domain does not exist: ${domain}`);\r\n        }\r\n\r\n        return domainLdap\r\n            .searchByUsername({ username, loggerContext })\r\n            .then((user) => {\r\n                if (user && this.cache) {\r\n                    this.logger.debug!({\r\n                        message: `To cache from domain ${domain}: ${user.dn}`,\r\n                        context: LdapService.name,\r\n                        function: 'searchByUsername',\r\n                        ...loggerContext,\r\n                    });\r\n                    this.cache.set<LDAPCache>(\r\n                        `dn:${domain}:${user.dn}`,\r\n                        { user, password: LDAP_PASSWORD_NULL },\r\n                        { ttl: this.cacheTtl },\r\n                    );\r\n\r\n                    if (user.sAMAccountName) {\r\n                        this.logger.debug!({\r\n                            message: `To cache from domain ${domain}: ${user.sAMAccountName}`,\r\n                            context: LdapService.name,\r\n                            function: 'searchByUsername',\r\n                            ...loggerContext,\r\n                        });\r\n                        this.cache.set<LDAPCache>(\r\n                            `user:${domain}:${user.sAMAccountName}`,\r\n                            { user, password: LDAP_PASSWORD_NULL },\r\n                            { ttl: this.cacheTtl },\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return user;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Search user by DN\r\n     *\r\n     * @async\r\n     * @param {string} userByDN user distinguished name\r\n     * @returns {Promise<LdapResponseUser>} User in LDAP\r\n     */\r\n    public async searchByDN({\r\n        dn,\r\n        domain,\r\n        cache = true,\r\n        loggerContext,\r\n    }: {\r\n        dn: string;\r\n        domain: string;\r\n        cache?: boolean;\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<LdapResponseUser | null | undefined> {\r\n        if (!domain || !dn) {\r\n            throw new Error(`Arguments domain=${domain}, userByDN=${dn}`);\r\n        }\r\n\r\n        const cachedID = `dn:${domain}:${dn}`;\r\n        if (cache && this.cache) {\r\n            // Check cache. 'cached' is `{password: <hashed-password>, user: <user>}`.\r\n            const cached = await this.cache.get<LDAPCache>(cachedID);\r\n            if (cached?.user.dn) {\r\n                this.logger.debug!({\r\n                    message: `From cache: ${cached.user.dn}`,\r\n                    context: LdapService.name,\r\n                    function: 'searchByDN',\r\n                    ...loggerContext,\r\n                });\r\n\r\n                return cached.user as LdapResponseUser;\r\n            }\r\n        }\r\n\r\n        const domainLdap = this.ldapDomains.find(\r\n            (value) => value.domainName === domain,\r\n        );\r\n        if (!domainLdap) {\r\n            this.logger.debug!({\r\n                message: `Domain does not exist: ${domain}`,\r\n                context: LdapService.name,\r\n                function: 'searchByDN',\r\n                ...loggerContext,\r\n            });\r\n            throw new Error(`Domain does not exist: ${domain}`);\r\n        }\r\n\r\n        return domainLdap.searchByDN({ dn, loggerContext }).then((user) => {\r\n            if (user && this.cache) {\r\n                this.logger.debug!({\r\n                    message: `To cache, domain \"${domain}\": ${user.dn}`,\r\n                    context: LdapService.name,\r\n                    function: 'searchByDN',\r\n                    ...loggerContext,\r\n                });\r\n                this.cache.set<LDAPCache>(\r\n                    cachedID,\r\n                    { user, password: LDAP_PASSWORD_NULL },\r\n                    { ttl: this.cacheTtl },\r\n                );\r\n\r\n                if (user.sAMAccountName) {\r\n                    this.logger.debug!({\r\n                        message: `To cache, domain \"${domain}\": ${user.sAMAccountName}`,\r\n                        context: LdapService.name,\r\n                        function: 'searchByDN',\r\n                        ...loggerContext,\r\n                    });\r\n                    this.cache.set<LDAPCache>(\r\n                        `user:${domain}:${user.sAMAccountName}`,\r\n                        { user, password: LDAP_PASSWORD_NULL },\r\n                        { ttl: this.cacheTtl },\r\n                    );\r\n                }\r\n            }\r\n\r\n            return user;\r\n        }).catch((error) => {\r\n            if (error instanceof Ldap.NoSuchObjectError) {\r\n                return null;\r\n            } else {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Synchronize users\r\n     *\r\n     * @async\r\n     * @returns {Record<string, LdapResponseUser[]>} User in LDAP\r\n     * @throws {Error}\r\n     */\r\n    public async synchronization({\r\n        loggerContext,\r\n    }: {\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<Record<string, Error | LdapResponseUser[]>> {\r\n        return Promise.all(\r\n            this.ldapDomains\r\n                .filter((domain) => !domain.hideSynchronization)\r\n                .map(async (domain) =>\r\n                    domain.synchronization({ loggerContext }),\r\n                ),\r\n        ).then((promise) =>\r\n            promise.reduce(\r\n                (accumulator, domain) => ({ ...accumulator, ...domain }),\r\n                {},\r\n            ),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Synchronize users\r\n     *\r\n     * @async\r\n     * @returns {Record<string, LdapResponseGroup[]>} Group in LDAP\r\n     * @throws {Error}\r\n     */\r\n    public async synchronizationGroups({\r\n        loggerContext,\r\n    }: {\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<Record<string, Error | LdapResponseGroup[]>> {\r\n        return Promise.all(\r\n            this.ldapDomains\r\n                .filter((domain) => !domain.hideSynchronization)\r\n                .map(async (domain) =>\r\n                    domain.synchronizationGroups({ loggerContext }),\r\n                ),\r\n        ).then((promise) =>\r\n            promise.reduce(\r\n                (accumulator, domain) => ({ ...accumulator, ...domain }),\r\n                {},\r\n            ),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Modify using the admin client.\r\n     *\r\n     * @public\r\n     * @async\r\n     * @param {string} dn LDAP Distiguished Name\r\n     * @param {Change[]} data LDAP modify data\r\n     * @param {string} username The optional parameter\r\n     * @param {string} password The optional parameter\r\n     * @returns {boolean} The result\r\n     * @throws {Ldap.Error}\r\n     */\r\n    public async modify({\r\n        dn,\r\n        data,\r\n        domain,\r\n        username,\r\n        password,\r\n        loggerContext,\r\n    }: {\r\n        dn: string;\r\n        data: Change[];\r\n        domain: string;\r\n        username?: string;\r\n        password?: string;\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<boolean> {\r\n        const domainLdap = this.ldapDomains.find(\r\n            (value) => value.domainName === domain,\r\n        );\r\n        if (!domainLdap) {\r\n            this.logger.debug!({\r\n                message: `Domain does not exist: ${domain}`,\r\n                context: LdapService.name,\r\n                function: 'modify',\r\n                ...loggerContext,\r\n            });\r\n            throw new Error(`Domain does not exist: ${domain}`);\r\n        }\r\n\r\n        return domainLdap.modify({\r\n            dn,\r\n            data,\r\n            username,\r\n            password,\r\n            loggerContext,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Authenticate given credentials against LDAP server\r\n     *\r\n     * @async\r\n     * @param {string} username The username to authenticate\r\n     * @param {string} password The password to verify\r\n     * @param {string} domain The domain to check\r\n     * @returns {LdapResponseUser} User in LDAP\r\n     * @throws {Error}\r\n     */\r\n    public async authenticate({\r\n        username,\r\n        password,\r\n        domain,\r\n        cache = true,\r\n        loggerContext,\r\n    }: {\r\n        username: string;\r\n        password: string;\r\n        domain: string;\r\n        cache?: boolean;\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<LdapResponseUser> {\r\n        if (!password) {\r\n            this.logger.error({\r\n                message: `${domain}: No password given`,\r\n                error: `${domain}: No password given`,\r\n                context: LdapService.name,\r\n                function: 'authenticate',\r\n                ...loggerContext,\r\n            });\r\n            throw new Error('No password given');\r\n        }\r\n\r\n        const domainLdap = this.ldapDomains.find(\r\n            (value) => value.domainName === domain,\r\n        );\r\n        if (!domainLdap) {\r\n            this.logger.debug!({\r\n                message: `Domain does not exist: ${domain}`,\r\n                context: LdapService.name,\r\n                function: 'authenticate',\r\n                ...loggerContext,\r\n            });\r\n            throw new Error(`Domain does not exist: ${domain}`);\r\n        }\r\n\r\n        const cachedID = `user:${domain}:${username}`;\r\n        if (cache && this.cache) {\r\n            // Check cache. 'cached' is `{password: <hashed-password>, user: <user>}`.\r\n            const cached = await this.cache.get<LDAPCache>(cachedID);\r\n            if (\r\n                cached?.user?.sAMAccountName &&\r\n                (cached?.password === LDAP_PASSWORD_NULL ||\r\n                    bcrypt.compareSync(password, cached.password))\r\n            ) {\r\n                this.logger.debug!({\r\n                    message: `From cache ${domain}: ${cached.user.sAMAccountName}`,\r\n                    context: LdapService.name,\r\n                    function: 'authenticate',\r\n                    ...loggerContext,\r\n                });\r\n\r\n                (async (): Promise<void> => {\r\n                    try {\r\n                        const user = await domainLdap.authenticate({\r\n                            username,\r\n                            password,\r\n                            loggerContext,\r\n                        });\r\n                        if (\r\n                            JSON.stringify(user) !==\r\n                                JSON.stringify(cached.user) &&\r\n                            this.cache\r\n                        ) {\r\n                            this.logger.debug!({\r\n                                message: `To cache from domain ${domain}: ${user.sAMAccountName}`,\r\n                                context: LdapService.name,\r\n                                function: 'authenticate',\r\n                                ...loggerContext,\r\n                            });\r\n\r\n                            this.cache.set<LDAPCache>(\r\n                                `user:${domain}:${user.sAMAccountName}`,\r\n                                {\r\n                                    user,\r\n                                    password: bcrypt.hashSync(\r\n                                        password,\r\n                                        this.cacheSalt,\r\n                                    ),\r\n                                },\r\n                                { ttl: this.cacheTtl },\r\n                            );\r\n                        }\r\n                    } catch (error) {\r\n                        const errorMessage =\r\n                            error instanceof Error\r\n                                ? error.toString()\r\n                                : JSON.stringify(error);\r\n                        this.logger.error({\r\n                            message: `LDAP auth error [${domain}]: ${errorMessage}`,\r\n                            error,\r\n                            context: LdapService.name,\r\n                            function: 'authenticate',\r\n                            ...loggerContext,\r\n                        });\r\n                    }\r\n                })();\r\n\r\n                return cached.user;\r\n            }\r\n        }\r\n\r\n        return domainLdap\r\n            .authenticate({\r\n                username,\r\n                password,\r\n                loggerContext,\r\n            })\r\n            .then((user) => {\r\n                if (this.cache) {\r\n                    this.logger.debug!({\r\n                        message: `To cache from domain ${domain}: ${user.sAMAccountName}`,\r\n                        context: LdapService.name,\r\n                        function: 'authenticate',\r\n                        ...loggerContext,\r\n                    });\r\n\r\n                    this.cache.set<LDAPCache>(\r\n                        `user:${domain}:${user.sAMAccountName}`,\r\n                        {\r\n                            user,\r\n                            password: bcrypt.hashSync(password, this.cacheSalt),\r\n                        },\r\n                        { ttl: this.cacheTtl },\r\n                    );\r\n                }\r\n\r\n                return user;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Trusted domain\r\n     *\r\n     * @async\r\n     * @returns {LdapTrustedDomain} ?\r\n     * @throws {Error}\r\n     */\r\n    public async trustedDomain({\r\n        searchBase,\r\n        domain,\r\n        loggerContext,\r\n    }: {\r\n        searchBase: string;\r\n        domain: string;\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<any> {\r\n        const trustedDomain = '';\r\n\r\n        return trustedDomain;\r\n    }\r\n\r\n    /**\r\n     * This is add a LDAP object\r\n     *\r\n     * @async\r\n     * @param {Record<string, string>} value\r\n     * @returns {LdapResponseUser} User | Profile in LDAP\r\n     * @throws {Error}\r\n     */\r\n    public async add({\r\n        entry,\r\n        domain,\r\n        loggerContext,\r\n    }: {\r\n        entry: LdapAddEntry;\r\n        domain: string;\r\n        loggerContext?: LoggerContext;\r\n    }): Promise<LdapResponseUser> {\r\n        const domainLdap = this.ldapDomains.find(\r\n            (value) => value.domainName === domain,\r\n        );\r\n        if (!domainLdap) {\r\n            this.logger.debug!({\r\n                message: `Domain does not exist: ${domain}`,\r\n                context: LdapService.name,\r\n                function: 'add',\r\n                ...loggerContext,\r\n            });\r\n            throw new Error(`Domain does not exist: ${domain}`);\r\n        }\r\n\r\n        return domainLdap.add({ entry, loggerContext });\r\n    }\r\n\r\n    /**\r\n     * Unbind connections\r\n     *\r\n     * @async\r\n     * @returns {Promise<boolean[]>}\r\n     */\r\n    public async close(): Promise<boolean[]> {\r\n        const promiseDomain = this.ldapDomains.map(async (domain) =>\r\n            domain.close(),\r\n        );\r\n        return Promise.all(promiseDomain).then((values) => values || []);\r\n    }\r\n}\r\n"]}